# Учебный проект по Python
# Критерии оценки
## Работа с Git и GitHub
- Домашка сдана через 'pull request' из ветки домашней работы в ветку 'develop'.
- Создан GitHub-репозиторий.
- В репозитории на GitHub есть ветки 'main' и 'develop'.
- Разработка велась в ветке с префиксом 'feature/homework_10_1'.
- Соблюдается точечность коммитов — в pull request более 2 коммитов.
- В репозитории есть оформленный по правилам README-файл с описанием проекта.
- В коммиты не добавлены игнорируемые файлы.
## Реализация функций
- Функция принимает на вход список словарей с данными о банковских операциях и параметр 'state', возвращает новый список, содержащий только те словари, у которых ключ
'state'содержит переданное в функцию значение.
- Параметр 'state' функции имеет значение по умолчанию 'EXECUTED'.
- Функция принимает на вход список словарей и параметр порядка сортировки, возвращает новый список, в котором исходные словари отсортированы по дате.
- Параметр порядка сортировки функции имеет значение по умолчанию 'True'.
## Оформление кода
- При вызове -'isort' форматируется не более 1 импорта.
- При запуске линтеров Flake8 и mypy выдается не более 4 ошибок.
- Для всех реализованных функций написаны docstring.
- Для параметров и возвращаемых значений функции описаны корректные аннотации типов.
- Нейминг функций отвечает правилам оформления кода PEP 8.
- Все функции названы в соответствии с условиями задания.

# Задание
Продолжаем работу над виджетом банковских операций клиента. Выкладываем свой проект на GitHub и ведем разработку по GitFlow. Учитываем рекомендации PEP 8, продолжаем использовать линтеры и делаем атомарные коммиты.

## Задачи
1. Создайте новые ветки в вашем репозитории для работы по GitFlow.
2. Создайте новый репозиторий на GitHub, который будет использоваться для хранения и совместной работы над вашим проектом.
3. Залейте содержимое вашего локального репозитория в созданный репозиторий на GitHub, используя команды 'git add', 'git commit' и 'git push'.
4. В директории 'src' вашего проекта создайте модуль 'processing', который будет содержать новые функции обработки данных.
5. В модуле 'processing' напишите функцию 'filter_by_state', которая принимает список словарей и опционально значение для ключа 'state' (по умолчанию 'EXECUTED').
Функция возвращает новый список словарей, содержащий только те словари, у которых ключ 'state' соответствует указанному значению.

**Примеры работы функции**

*Выход функции со статусом по умолчанию 'EXECUTED'*
```
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}]
```

*Выход функции, если вторым аргументов передано 'CANCELED'*
```
[{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```
*Пример входных данных для проверки функции*
```
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'},
{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```

6. В том же модуле напишите функцию 'sort_by_date', которая принимает список словарей и необязательный параметр, задающий порядок сортировки (по умолчанию — убывание).
Функция должна возвращать новый список, отсортированный по дате (date).

**Примеры работы функции**

*Выход функции (сортировка по убыванию, т. е. сначала самые последние операции)*
```
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'},
{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'}]
```

*Пример входных данных для проверки функции*
```
[{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'},
{'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'}, {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```

7. Создайте README-файл для вашего проекта, в котором описаны цель проекта, инструкции по установке и использованию разработанных функций, примеры работы с ними.

# Цель проекта
Целью проекта является написание функций для работы с данными о банковских операциях, позволяющими представлять средства для фильтрации и сортировки операций по заданным критериям и демонстрировать умение работать в команде с использованием GitFlow при соблюдении стиля кода PEP 8.

# Использование разработанных функций
Все функции находятся в модуле processing.py. Ниже приведены примеры использования.

**Пример данных для тестирования:**

*Ожидаемый результат (сортировка по ключу 'state'):*
```
list_of_test = [{'id': 41428829, 'state': 'EXECUTED', 'date': '2019-07-03T18:35:29.512364'}, 
                {'id': 939719570, 'state': 'EXECUTED', 'date': '2018-06-30T02:08:58.425572'},
                {'id': 594226727, 'state': 'CANCELED', 'date': '2018-09-12T21:27:25.241689'},
               {'id': 615064591, 'state': 'CANCELED', 'date': '2018-10-14T08:21:33.419441'}]
```
# Функция sort_by_date
```
from typing import List, Dict
from datetime import datetime

def filter_by_state(id_numbers: str, state='EXECUTED') -> List[Dict]:

 
    filter_default_key = [item for item in id_numbers if item.get('state') == state]
    filter_specified_state = [item for item in id_numbers if item.get('state') != state]

    return (filter_default_key, filter_specified_state)
```
# Функция filter_by_state
```
def sort_by_date(data: List[Dict], reverse: bool = True) -> List[Dict]:
      return sorted(data, key=lambda x: datetime.fromisoformat(x['date']), reverse=reverse)
```

# Тестирование Pytest
Тестирование кода играет важную роль в разработке программного обеспечения. Оно не просто помогает обнаруживать ошибки и проблемы в коде до того, как продукт будет выпущен, но также способствует высокому качеству и надежности программных решений.

**Причины, почему регулярное и систематическое тестирование так важно:**

Обеспечение качества и надежности. Тесты позволяют убедиться, что код работает так, как ожидалось, и выполняет все свои функции без ошибок. Это особенно важно для финансовых и коммерческих приложений, над которым мы работаем, где ошибки могут привести к серьезным финансовым потерям или ущербу для репутации.
Повышение уверенности при внесении изменений. Автоматизированные тесты предоставляют инструмент безопасности, позволяя разработчикам вносить изменения в код без страха случайно что-то сломать. При добавлении нового функционала, просто запустив тесты, можно убедиться в том, что весь предыдущий функционал работает как должен. Это особенно важно в больших и сложных системах.
Ускорение процесса разработки. Несмотря на то что написание тестов требует времени, оно на самом деле ускоряет разработку за счет снижения количества времени, затрачиваемого на отладку и исправление ошибок в будущем. Тесты также делают изменение и обновление кода более безопасными и предсказуемыми.
Обеспечение совместимости и соответствия. Регулярное тестирование помогает гарантировать, что изменения в одной части системы не нарушают функциональности в других частях.
Таким образом, тестирование является неотъемлемой частью процесса разработки и помогают поддерживать высокий уровень качества вашего приложения.

# Тестирование
Вводим команду 'pytest --cov=src --cov-report=html' чтобы сгенерировать отчет о покрытии в HTML-формате, где src — пакет c модулями, которые тестируем. Отчет сгенерирован в папке htmlcov и храниться в файле с названием index.html.

*Результаты тестирования*
```
========================== tests coverage =========================== 
__________ coverage: platform win32, python 3.13.3-final-0 ___________ 

Name                       Stmts   Miss  Cover
----------------------------------------------
src\__init__.py                0      0   100%
src\masks.py                   8      0   100%
src\processing.py             14      0   100%
src\widget.py                 19      0   100%
tests\__init__.py              0      0   100%
tests\test_masks.py            9      0   100%
tests\test_processing.py      18      1    94%
tests\test_widget.py           9      0   100%
----------------------------------------------
TOTAL                         77      1    99%
========================= 21 passed in 0.14s =========================
```

# Включения и генераторы

**Задачи**
1. Создайте новый модуль в вашем проекте под названием 'generators'. Этот модуль будет содержать все новые функции, реализующие генераторы для обработки данных.
2. Создайте функцию 'filter_by_currency', которая принимает на вход список словарей, представляющих транзакции.
Функция должна возвращать итератор, который поочередно выдает транзакции, где валюта операции соответствует заданной (например, USD).

```
usd_transactions = filter_by_currency(transactions, "USD")
for _ in range(2):
    print(next(usd_transactions))

>>> {
          "id": 939719570,
          "state": "EXECUTED",
          "date": "2018-06-30T02:08:58.425572",
          "operationAmount": {
              "amount": "9824.07",
              "currency": {
                  "name": "USD",
                  "code": "USD"
              }
          },
          "description": "Перевод организации",
          "from": "Счет 75106830613657916952",
          "to": "Счет 11776614605963066702"
      }
      {
              "id": 142264268,
              "state": "EXECUTED",
              "date": "2019-04-04T23:20:05.206878",
              "operationAmount": {
                  "amount": "79114.93",
                  "currency": {
                      "name": "USD",
                      "code": "USD"
                  }
              },
              "description": "Перевод со счета на счет",
              "from": "Счет 19708645243227258542",
              "to": "Счет 75651667383060284188"
       }
```

3. Напишите генератор 'transaction_descriptions', который принимает список словарей с транзакциями и возвращает описание каждой операции по очереди.

```
descriptions = transaction_descriptions(transactions)
for _ in range(5):
    print(next(descriptions))

>>> Перевод организации
    Перевод со счета на счет
    Перевод со счета на счет
    Перевод с карты на карту
    Перевод организации
```

4. Создайте генератор 'card_number_generator', который выдает номера банковских карт в формате XXXX XXXX XXXX XXXX, где X
 — цифра номера карты. Генератор может сгенерировать номера карт в заданном диапазоне от 0000 0000 0000 0001 до 9999 9999 9999 9999.
Генератор должен принимать начальное и конечное значения для генерации диапазона номеров.

```
for card_number in card_number_generator(1, 5):
    print(card_number)

0000 0000 0000 0001
0000 0000 0000 0002
0000 0000 0000 0003
0000 0000 0000 0004
0000 0000 0000 0005
```

5. Напишите тесты для нового функционала проекта. Добейтесь покрытия тестами не менее 80% кода.

```
Примеры тест-кейсов. 
*Тестирование функции 'filter_by_currency':*
Напишите тесты, проверяющие, что функция корректно фильтрует транзакции по заданной валюте.
Проверьте, что функция правильно обрабатывает случаи, когда транзакции в заданной валюте отсутствуют.
Убедитесь, что генератор не завершается ошибкой при обработке пустого списка или списка без соответствующих валютных операций.

**Тестирование функции 'transaction_descriptions':
Проверьте, что функция возвращает корректные описания для каждой транзакции.
Тестируйте работу функции с различным количеством входных транзакций, включая пустой список.

*Тестирование генератора 'card_number_generator':*
Напишите тесты, которые проверяют, что генератор выдает правильные номера карт в заданном диапазоне.
Проверьте корректность форматирования номеров карт.
Убедитесь, что генератор корректно обрабатывает крайние значения диапазона и правильно завершает генерацию.
```
**Входные данные к проекту**

Для проверки функций 'filter_by_currency' и 'transaction_descriptions':
```
transactions = (
    [
        {
            "id": 939719570,
            "state": "EXECUTED",
            "date": "2018-06-30T02:08:58.425572",
            "operationAmount": {
                "amount": "9824.07",
                "currency": {
                    "name": "USD",
                    "code": "USD"
                }
            },
            "description": "Перевод организации",
            "from": "Счет 75106830613657916952",
            "to": "Счет 11776614605963066702"
        },
        {
            "id": 142264268,
            "state": "EXECUTED",
            "date": "2019-04-04T23:20:05.206878",
            "operationAmount": {
                "amount": "79114.93",
                "currency": {
                    "name": "USD",
                    "code": "USD"
                }
            },
            "description": "Перевод со счета на счет",
            "from": "Счет 19708645243227258542",
            "to": "Счет 75651667383060284188"
        },
        {
            "id": 873106923,
            "state": "EXECUTED",
            "date": "2019-03-23T01:09:46.296404",
            "operationAmount": {
                "amount": "43318.34",
                "currency": {
                    "name": "руб.",
                    "code": "RUB"
                }
            },
            "description": "Перевод со счета на счет",
            "from": "Счет 44812258784861134719",
            "to": "Счет 74489636417521191160"
        },
        {
            "id": 895315941,
            "state": "EXECUTED",
            "date": "2018-08-19T04:27:37.904916",
            "operationAmount": {
                "amount": "56883.54",
                "currency": {
                    "name": "USD",
                    "code": "USD"
                }
            },
            "description": "Перевод с карты на карту",
            "from": "Visa Classic 6831982476737658",
            "to": "Visa Platinum 8990922113665229"
        },
        {
            "id": 594226727,
            "state": "CANCELED",
            "date": "2018-09-12T21:27:25.241689",
            "operationAmount": {
                "amount": "67314.70",
                "currency": {
                    "name": "руб.",
                    "code": "RUB"
                }
            },
            "description": "Перевод организации",
            "from": "Visa Platinum 1246377376343588",
            "to": "Счет 14211924144426031657"
        }
    ]
)
```

**Выполнение задания**
1. Функция ```filter_by_currency(transactions: List[Dict], currency: str) -> Generator[Union[Dict, str], None, None]```
*Описание: Эта функция возвращает итератор, который поочередно выдает транзакции, где валюта операции соответствует заданной. Если транзакции не найдены, возвращает строку "Нет значений".*

```transactions:``` список словарей с транзакциями.
```currency:``` строка, позволяющая выбрать тип валюты.
Возвращает: генератор, который выдает либо словарь с транзакцией, либо строку.
*Пример:*
```
usd_transactions = filter_by_currency(transactions, "USD") for transaction in usd_transactions: print(transaction)
```

2. Генератор ```transaction_descriptions(transactions: List[Dict]) -> Generator[str, None, None]```
*Описание: Эта функция принимает список словарей с транзакциями и возвращает описание каждой операции по очереди. Если описание отсутствует, возвращает "Описание отсутствует".*

```transactions:``` список словарей с транзакциями.
Возвращает: генератор строк, содержащих описания транзакций.
*Пример:*
```
descriptions = transaction_descriptions(transactions) for description in descriptions: print(description)
```

3. Генератор ```card_number_generator(start: int, stop: int) -> Generator[str, None, None]```
*Описание: Генератор, который выдает номера банковских карт в формате: XXXX XXXX XXXX XXXX. Номера генерируются на основе заданного диапазона.*

```start:``` начальное значение диапазона (включительно).
```stop:``` конечное значение диапазона (включительно).
Возвращает: генератор строк, представляющих номера карт.
*Пример:*
```
for card_number in card_number_generator(1, 5): print(card_number)
```

# Тестирование
Вводим команду 'pytest --cov=src --cov-report=html' чтобы сгенерировать отчет о покрытии в HTML-формате, где src — пакет c модулями, которые тестируем. Отчет сгенерирован в папке htmlcov и храниться в файле с названием index.html.

*Результаты тестирования*
```
================================ tests coverage =================================
________________ coverage: platform win32, python 3.13.3-final-0 _________________

Name                       Stmts   Miss  Cover
----------------------------------------------
src\__init__.py                0      0   100%
src\generators.py             22      3    86%
src\masks.py                   8      0   100%
src\processing.py             14      0   100%
src\widget.py                 27      0   100%
tests\__init__.py              0      0   100%
tests\test_generators.py      33      0   100%
tests\test_masks.py            9      0   100%
tests\test_processing.py      18      1    94%
tests\test_widget.py           9      0   100%
----------------------------------------------
TOTAL                        140      4    97%
=============================== 27 passed in 0.18s ===============================
```

# Декораторы

**Задачи**
1. Создайте новый модуль в вашем проекте, который будет называться 'decorators'. Этот модуль будет использоваться для размещения декораторов,
включая декоратор 'log'.
2. Напишите декоратор 'log', который будет автоматически логировать начало и конец выполнения функции, а также ее результаты или возникшие ошибки.
Декоратор должен принимать необязательный аргумент 'filename', который определяет, куда будут записываться логи (в файл или в консоль):
Если 'filename' задан, логи записываются в указанный файл.
Если 'filename'  не задан, логи выводятся в консоль.

Логирование должно включать:
Имя функции и результат выполнения при успешной операции.
Имя функции, тип возникшей ошибки и входные параметры, если выполнение функции привело к ошибке.

*Пример использования декоратора*
```
@log(filename="mylog.txt")
def my_function(x, y):
    return x + y

my_function(1, 2)
```
Ожидаемый вывод в лог-файл mylog.txt  при успешном выполнении:
```
my_function ok
```
Ожидаемый вывод при ошибке:
```
my_function error: тип ошибки. Inputs: (1, 2), {}
```
Где тип ошибки  заменяется на текст ошибки.

3. Используйте 'pytest' для написания тестов, проверяющих функциональность декоратора.
Для тестирования вывода в консоль примените фикстуру 'capsys', которая позволяет перехватывать вывод данных в консоль.
Убедитесь, что тесты покрывают различные сценарии использования декоратора, включая успешное выполнение функций и обработку исключений.

**Выполнение задания**
1. Создан модуль 'decorators'. В модуле реализован декоратор 'log'.
Декоратор может логировать работу функции и ее результат как в файл, так и в консоль.
Декоратор 'log' принимает необязательный аргумент 'filename', который определяет имя файла, в который будут записываться логи.
Если 'filename'  не задан, то логи выводятся в консоль.
Если вызов функции закончился ошибкой, записывается сообщение об ошибке и входные параметры функции.
2. Проведено тестирование декораторов. Написаны тесты к декоратору.
Функциональный код покрыт тестами на 95% (Модули 'decorators.py', 'test_decorators.py' покрыты тестами в среднем на 90%).
При запуске тестов командой 'pytest'  все тесты завершаются успешно.
В репозитории есть папка 'htmlcov' (файл 'index.html') с отчетом покрытия тестами в формате HTML.
3. Код оформлен и откорректирован по линтерам Flake8, Black - ошибки исправлены.
Для всех реализованных функций написаны 'docstring'. Имена функций отвечает правилам оформления кода PEP 8.
 При вызове isort форматируется не более 1 импорта.

*Результаты тестирования*
```
================================= tests coverage ================================= 
________________ coverage: platform win32, python 3.13.3-final-0 _________________ 

Name                       Stmts   Miss  Cover
----------------------------------------------
src\__init__.py                0      0   100%
src\decorators.py             34      3    91%
src\generators.py             22      3    86%
src\masks.py                   8      0   100%
src\processing.py             14      0   100%
src\widget.py                 27      0   100%
tests\__init__.py              0      0   100%
tests\test_decorators.py      27      3    89%
tests\test_generators.py      33      0   100%
tests\test_masks.py            9      0   100%
tests\test_processing.py      18      1    94%
tests\test_widget.py           9      0   100%
----------------------------------------------
TOTAL                        201     10    95%
=============================== 29 passed in 0.20s =============================== 
```

# Библиотеки json, requests и datetime
** Задачи
1. Реализуйте функцию, которая принимает на вход путь до JSON-файла и возвращает список словарей с данными о финансовых транзакциях. Если файл пустой, содержит не список или не найден, функция возвращает пустой список. Функцию поместите в модуль 'utils'. Файл с данными о финансовых транзациях 'operations.json'  поместите в директорию 'data/'  в корне проекта. 
Ссылка на файл: operations.json.

2. Реализуйте функцию, которая принимает на вход транзакцию и возвращает сумму транзакции (amount) в рублях, тип данных — float. Если транзакция была в USD  или EUR, происходит обращение к внешнему API для получения текущего курса валют и конвертации суммы операции в рубли. Для конвертации валюты воспользуйтесь Exchange Rates Data API: https://apilayer.com/exchangerates_data-api. Функцию конвертации поместите в модуль 'external_api'.
Используйте переменные окружения из файла .env  для сокрытия чувствительных данных (токенов доступа для API). Создайте шаблон файла .env  и разместите в репозитории на GitHub.
3. Напишите тесты для новых функций, используйте Mock и patch.
   
** Выполнение
1. Создан модуль 'utils'. В модуле реализована функция 'load_transactions'. 
   ```
def load_transactions(file_path):
    """Загрузить транзакции из JSON-файла."""
```
Создан файл 'operations.json' в директории 'data/'.
3. Функция конвертации валют в рубли 'convert_to_rub' находится в модуле 'external_api'
```
def convert_to_rub(currencys: str) -> float:
    """Функция конвертации валюты"""
```
4. Для сокрытия персональных данных создан файл '.env'. Для демонстрации создан файл '.env.example' в корне проекта.
5. Написаны тесты для новых функций с использованием Mock и patch.
6. Код оформлен и откорректирован по линтерам Flake8, Black - ошибки исправлены.
Для всех реализованных функций написаны 'docstring'. Имена функций отвечает правилам оформления кода PEP 8.
 При вызове isort форматируется не более 1 импорта.

*Результаты тестирования*

```
======================= tests coverage ======================== 

Name                         Stmts   Miss  Cover
------------------------------------------------
src\__init__.py                  0      0   100%
src\external_api.py             24      1    96%
src\generators.py               22      3    86%
src\masks.py                     8      0   100%
src\processing.py               14      0   100%
src\utils.py                    13      0   100%
src\widget.py                   27      0   100%
tests\__init__.py                0      0   100%
tests\test_external_api.py       5      0   100%
tests\test_generators.py        33      0   100%
tests\test_masks.py              9      0   100%
tests\test_processing.py        18      1    94%
tests\test_utils.py             36      1    97%
tests\test_widget.py             9      0   100%
------------------------------------------------
TOTAL                          218      6    97%
===================== 35 passed in 3.32s ====================== 
```

Функциональный код покрыт тестами больше 80%.

Вводим команду 'pytest --cov=src --cov-report=html' чтобы сгенерировать отчет о покрытии в HTML-формате, где src — пакет c модулями, которые тестируем. Отчет сгенерирован в папке htmlcov и храниться в файле с названием index.html.

# Библиотеки csv и pandas #

**Задача**

1. Реализовать считывание финансовых операций из CSV- и XLSX-файлов.

# Выполнение 
1. Скачаны файлы 'transactions.csv' и 'transactions_excel.xlsx' для работы над задачами.
2. Создан отдельный модуль для новых функций.
3. Реализованы функции, которые считывают финансовые операции
- из CSV файла:
```def read_transactions_from_csv(file_path):```
- из Excel файла:
```read_transactions_from_excel(file_path:```

4. Все необходимые для работы библиотеки добавлены в зависимости проекта.

# Тестирование

1. Написаны тесты к новым функциональностям проекта.
2. Тесты для функции считывания финансовых операций из CSV используют Mock и patch.
3. Тесты для функции считывания финансовых операций из Excel используют Mock и patch.
4. При запуске тестов командой 'pytest' все тесты завершаются успешно.

*Результаты тестирования*
```
=================== tests coverage ==================== 


Name                               Stmts   Miss  Cover  
------------------------------------------------------  
src\__init__.py                        0      0   100%  
src\decorators.py                     34      3    91%  
src\external_api.py                   27      5    81%  
src\generators.py                     22      3    86%  
src\masks.py                          29      1    97%  
src\processing.py                     14      0   100%  
src\transaction_reader.py             35      7    80%  
src\utils.py                          27      1    96%  
src\widget.py                         36     10    72%  
tests\__init__.py                      0      0   100%  
tests\test_decorators.py              27      3    89%  
tests\test_external_api.py            27      1    96%  
tests\test_generators.py              33      0   100%  
tests\test_masks.py                   16      0   100%  
tests\test_processing.py              18      1    94%  
tests\test_transaction_reader.py      39      1    97%  
tests\test_utils.py                   36      1    97%  
tests\test_widget.py                  15      1    93%  
------------------------------------------------------  
TOTAL                                435     38    91%  
================= 41 passed in 0.96s ==================
```

Функциональный код покрыт тестами больше 80%.
